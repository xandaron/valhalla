#version 450

layout (binding = 0, rgba8) uniform readonly image2D inImage;
layout (binding = 1, rgba8) uniform writeonly image2D outImage;

// x * y * z <= 1024; must be true
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

vec4 eigenVector(ivec2 uv) {
    vec3 Sx = (
        1.0 * imageLoad(inImage, uv + ivec2(-1, -1)).rgb +
        2.0 * imageLoad(inImage, uv + ivec2(-1,  0)).rgb +
        1.0 * imageLoad(inImage, uv + ivec2(-1,  1)).rgb +
        -1.0 * imageLoad(inImage, uv + ivec2(1, -1)).rgb +
        -2.0 * imageLoad(inImage, uv + ivec2(1,  0)).rgb +
        -1.0 * imageLoad(inImage, uv + ivec2(1,  1)).rgb
    ) / 4.0;

    vec3 Sy = (
        1.0 * imageLoad(inImage, uv + ivec2(-1, -1)).rgb +
        2.0 * imageLoad(inImage, uv + ivec2( 0, -1)).rgb +
        1.0 * imageLoad(inImage, uv + ivec2( 1, -1)).rgb +
        -1.0 * imageLoad(inImage, uv + ivec2(-1, 1)).rgb +
        -2.0 * imageLoad(inImage, uv + ivec2( 0, 1)).rgb +
        -1.0 * imageLoad(inImage, uv + ivec2( 1, 1)).rgb
    ) / 4.0;

    return vec4(dot(Sx, Sx), dot(Sy, Sy), dot(Sx, Sy), 1.0);
}

int radius = 8;

float hardness = 17.0;
float sharpness = 10.0;
float alpha = 2.0;

float zeta = 0.2;
float zeroCross = 0.4;
float sinZeroCross = sin(zeroCross);
float eta = (zeta + cos(zeroCross)) / (sinZeroCross * sinZeroCross);

void main() {
    vec4 t = eigenVector(ivec2(gl_GlobalInvocationID.xy));

    float a = float(radius) * clamp((alpha + t.w) / alpha, 0.1, 2.0);
    float b = float(radius) * clamp(alpha / (alpha + t.w), 0.1, 2.0);

    float cos_phi = cos(t.z);
    float sin_phi = sin(t.z);

    mat2 R = mat2(
        cos_phi, -sin_phi,
        sin_phi, cos_phi
    );

    mat2 S = mat2(
        0.5 / a, 0.0,
        0.0, 0.5 / b
    );

    mat2 SR = S * R;

    int max_x = int(sqrt(a * a * cos_phi * cos_phi + b * b * sin_phi * sin_phi));
    int max_y = int(sqrt(a * a * sin_phi * sin_phi + b * b * cos_phi * cos_phi));

    vec4[8] m;
    vec3[8] s;

    for (int i = 0; i < 8; i++) {
        m[i] = vec4(0.0, 0.0, 0.0, 0.0);
        s[i] = vec3(0.0, 0.0, 0.0);
    }

    ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

    for (int x = -max_x; x <= max_x; x++) {
        for (int y = -max_y; y <= max_y; y++) {
            vec2 v = SR * vec2(x, y);
            if (dot(v, v) > 0.25) {
                continue;
            }
            vec3 colour = imageLoad(inImage, uv + ivec2(x, y)).xyz;
            float[8] weights;

            float sum = 0.0;
            float vxx = zeta - eta * v.x * v.x;
            float vyy = zeta - eta * v.y * v.y;

            float z = max(0, v.y + vxx);
            weights[0] = z * z;
            sum += weights[0];

            z = max(0, -v.x + vyy);
            weights[2] = z * z;
            sum += weights[2];

            z = max(0, -v.y + vxx); 
            weights[4] = z * z;
            sum += weights[4];

            z = max(0, v.x + vyy); 
            weights[6] = z * z;
            sum += weights[6];

            v = sqrt(2.0) / 2.0 * vec2(v.x - v.y, v.x + v.y);
            vxx = zeta - eta * v.x * v.x;
            vyy = zeta - eta * v.y * v.y;

            z = max(0, v.y + vxx); 
            weights[1] = z * z;
            sum += weights[1];

            z = max(0, -v.x + vyy); 
            weights[3] = z * z;
            sum += weights[3];

            z = max(0, -v.y + vxx); 
            weights[5] = z * z;
            sum += weights[5];

            z = max(0, v.x + vyy); 
            weights[7] = z * z;
            sum += weights[7];

            float g = exp(-3.125 * dot(v,v)) / sum;
            for (int k = 0; k < 8; k++) {
                float wk = weights[k] * g;
                m[k] += vec4(colour * wk, wk);
                s[k] += colour * colour * wk;
            }
        }
    }

    vec4 outColour = vec4(0.0, 0.0, 0.0, 0.0);
    for (int k = 0; k < 8; k++) {
        m[k].rgb /= m[k].w;
        s[k] = abs(s[k] / m[k].w - m[k].rgb * m[k].rgb);

        float sigma2 = s[k].r + s[k].g + s[k].b;
        float w = 1.0 / (1.0 + pow(hardness * 1000.0 * sigma2, 0.5 * sharpness));

        outColour += vec4(m[k].rgb * w, w);
    }

    imageStore(outImage, uv, vec4(outColour.xyz / outColour.w, 1.0));
}