#version 450

layout (binding = 0, rgba8) uniform readonly image2D inImage;
layout (binding = 1, rgba8) uniform writeonly image2D outImage;

// x * y * z <= 1024; must be true
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

int radius = 4;

float zeta = 2.0 / radius;
float zeroCross = 5.0;
float sinZeroCross = sin(zeroCross);
float eta = (zeta + cos(zeroCross)) / (sinZeroCross * sinZeroCross);

void main() {
    vec4[8] m;
    vec3[8] s;

    for (int i = 0; i < 8; i++) {
        m[i] = vec4(0.0, 0.0, 0.0, 0.0);
        s[i] = vec3(0.0, 0.0, 0.0);
    }

    uint originX = gl_GlobalInvocationID.x;
    uint originY = gl_GlobalInvocationID.y;

    for (int x = -radius; x <= radius; x++) {
        for (int y = -radius; y <= radius; y++) {
            vec2 v = vec2(x, y);
            vec3 colour = imageLoad(inImage, ivec2(originX + x, originY + y)).xyz;
            float[8] weights;
            float sum = 0.0;
            float vxx = zeta - eta * v.x * v.x;
            float vyy = zeta - eta * v.y * v.y;
            float z = max(0, v.y + vxx);
            weights[0] = z * z;
            sum += weights[0];
            z = max(0, -v.x + vyy);
            weights[2] = z * z;
            sum += weights[2];
            z = max(0, -v.y + vxx); 
            weights[4] = z * z;
            sum += weights[4];
            z = max(0, v.x + vyy); 
            weights[6] = z * z;
            sum += weights[6];
            v = sqrt(2.0) / 2.0 * vec2(v.x - v.y, v.x + v.y);
            vxx = zeta - eta * v.x * v.x;
            vyy = zeta - eta * v.y * v.y;
            z = max(0, v.y + vxx); 
            weights[1] = z * z;
            sum += weights[1];
            z = max(0, -v.x + vyy); 
            weights[3] = z * z;
            sum += weights[3];
            z = max(0, -v.y + vxx); 
            weights[5] = z * z;
            sum += weights[5];
            z = max(0, v.x + vyy); 
            weights[7] = z * z;
            sum += weights[7];

            for (int k = 0; k < 8; k++) {
                float wk = weights[k] * exp(-3.125 * dot(v,v)) / sum;
                m[k] += vec4(colour * wk, wk);
                s[k] += colour * colour * wk;
            }
        }
    }

    vec4 outColour = vec4(0.0, 0.0, 0.0, 0.0);
    for (int k = 0; k < 8; k++) {
        m[k].xyz = m[k].xyz / m[k].w;
        s[k] = abs(s[k] / m[k].w - m[k].xyz * m[k].xyz);

        float sigma2 = s[k].x + s[k].y + s[k].z;
        float w = 1.0 / (1.0 + sigma2);

        outColour += vec4(m[k].xyz * w, w);
    }

    imageStore(outImage, ivec2(originX, originY), vec4(outColour.xyz / outColour.w, 1.0));
}